scheme rsl_examples = 
  class 
    type 
      /*
      sub-type (constrainted type),
      a list of exactly 8 natural numbers
      */
      PhoneNumber = {| phone_number : Nat-list :- len (phone_number) = 8 |} 
    	 
    value 
      increment : Nat -> Nat
      increment(x) is x + 1, 
      	
      phone_num : PhoneNumber = <.1, 2, 3, 4, 5, 6, 7, 8.>, 
      	 
      /*
      the type checker will complain about following phone number
      since it doesn't obey the PhoneNumber type.
      */
      /* not_a_phone_num : PhoneNumber <. 1,2, 3,4, 5,6, 7,8, 9 .> */

      -- a basic trivial recursive function 
      fibonacci : Nat -> Nat
      fibonacci(n) is 
        case n of
          0 -> 1,
          1 -> 1,
          _ -> fibonacci(n - 1) + fibonacci(n - 2)
        end, 
      	
      /*
      function which zips two lists together to one list of tuples....

      This version of the zip function passes on the intermediate result
      as an argument, and performs a call to the same function as the last step in each recursion. 
      This allows the SML compiler to perform tail-call-optimization
      which is an optimization where the stack frames are reused on each recursive
      function call and makes it possible to avoid stack-overflows as it will only
      be using one stack frame at all times. The tail-call-optimization can only be
      performed if the recursive function call is the last thing that happens at
      each recursion step (see zip2 for a function which cannot be
      tail-call-optimized).
      You might not encounter stack-overflow problems for the assignments in this
      course, but this is still essential knowledge about recursive functions. 
      */
      zip1 : Nat-list >< Nat-list >< (Nat >< Nat)-list -> (Nat >< Nat)-list
      zip1(l1, l2, result) is 
        if len l1 > 0 /\ len l2 > 0 
        then 
          let 
            h1 = hd l1, 
            h2 = hd l2, 
            t1 = tl l1, 
            t2 = tl l2, 
            result' = result ^ <.(h1, h2).> 
          in 
            zip1(t1, t2, result') 
          end 
        else result 
        end,

      /*
      zip two lists together to one list of tuples....

      This zip function has a concatenation as final step in each recursion,
      and thus it needs to 'remember' all previous stack-frames which makes
      it impossible for the SML compiler to perform tail-call-optimization.
      This function can potentially cause stack-overflow if given two very
      long lists.
      Use whichever type of recursion you prefer, they are both fine for most cases.
      */
      zip2 : Nat-list >< Nat-list -> (Nat >< Nat)-list
      zip2(l1, l2) is
        if len l1 > 0 /\ len l2 > 0 
        then 
          let 
            h1 = hd l1, 
            h2 = hd l2, 
            t1 = tl l1, 
            t2 = tl l2
          in 
            <. (h1,h2) .> ^ zip2(t1, t2) 
          end 
         else
          <. .>
         end
               
    	 
    test_case 
      [incr_test]
        increment(42), 
      [phone_num_test]
        phone_num, 
      [some_list]
        <.1, 2, 3.>, 
      [some_other_list]
        <.1 .. 10.>, 
      [some_list_comprehension]
        <.x | x in <.1 .. 10.> :- x \ 2 = 0.>, 
      [some_set_comprehension]
        {x | x : Nat :- x isin {1 .. 10} /\ x \ 2 = 0}, 
      [some_other_set_comprehension]
        {x + 1 | x : Nat :- x isin {0 .. 10} /\ x \ 2 = 0}, 
      [fibonacci_test]
        fibonacci(12), 
      [head_and_tail]
        let 
          some_list = <.1, 2, 3.>, 
          head = hd some_list, 
          tail = tl some_list 
        in 
          head = 1 /\ tail = <.2, 3.> 
        end, 
      [concat_lists] <.0, 1.> ^ <.2, 3.>,
      [zip1_test] zip1(<. 1,2,3 .>, <. 4,5,6 .>, <..>),
      [zip2_test] zip2(<. 1,2,3 .>, <. 4,5,6 .>),
  end
